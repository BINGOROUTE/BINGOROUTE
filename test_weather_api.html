<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>날씨 API 테스트</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .section { margin: 20px 0; padding: 20px; border: 1px solid #ddd; border-radius: 8px; }
        .weather-card { background: #f5f5f5; padding: 10px; margin: 5px 0; border-radius: 4px; }
        .score-circle { display: inline-block; width: 60px; height: 60px; border-radius: 50%; 
                       background: #667eea; color: white; text-align: center; line-height: 60px; 
                       font-weight: bold; margin-right: 10px; }
        .best-day { background: #e8f5e8; border-left: 4px solid #4caf50; }
        button { padding: 10px 20px; margin: 5px; background: #2563eb; color: white; 
                border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #1d4ed8; }
        pre { background: #f8f8f8; padding: 10px; border-radius: 4px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>🌤️ 날씨 API 테스트</h1>
    
    <div class="section">
        <h2>API 테스트</h2>
        <button onclick="testCurrentWeather()">현재 날씨 조회</button>
        <button onclick="testMidForecast()">중기 예보 조회</button>
        <button onclick="testWeatherStats()">날씨 통계 조회</button>
        <button onclick="testWeatherRecommendation()">날씨 추천 테스트</button>
    </div>

    <div class="section">
        <h2>결과</h2>
        <div id="result"></div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8000';

        async function testCurrentWeather() {
            try {
                const response = await fetch(`${API_BASE}/api/weather/current/`);
                const data = await response.json();
                
                if (data.success) {
                    let html = '<h3>현재 날씨 (서울 25개 구)</h3>';
                    Object.keys(data.data).slice(0, 5).forEach(region => {
                        const weather = data.data[region];
                        html += `<div class="weather-card">
                            <strong>${region}</strong>: ${weather['기온(℃)']}°C, 
                            습도 ${weather['습도(%)']}%, 풍속 ${weather['풍속(m/s)']}m/s
                        </div>`;
                    });
                    html += `<p>총 ${Object.keys(data.data).length}개 구 데이터</p>`;
                    document.getElementById('result').innerHTML = html;
                } else {
                    document.getElementById('result').innerHTML = `<p style="color: red;">오류: ${data.error}</p>`;
                }
            } catch (error) {
                document.getElementById('result').innerHTML = `<p style="color: red;">네트워크 오류: ${error.message}</p>`;
            }
        }

        async function testMidForecast() {
            try {
                const response = await fetch(`${API_BASE}/api/weather/mid-forecast/`);
                const data = await response.json();
                
                if (data.success) {
                    let html = '<h3>중기 예보 (서울)</h3>';
                    data.data.slice(0, 10).forEach(item => {
                        html += `<div class="weather-card">
                            <strong>${item.date}</strong> (${item.period}): 
                            ${item.weather_condition || '정보없음'}, 
                            강수확률 ${item.rain_probability || 0}%
                            ${item.min_temperature ? `, ${item.min_temperature}°~${item.max_temperature}°` : ''}
                        </div>`;
                    });
                    html += `<p>총 ${data.data.length}건 데이터</p>`;
                    document.getElementById('result').innerHTML = html;
                } else {
                    document.getElementById('result').innerHTML = `<p style="color: red;">오류: ${data.error}</p>`;
                }
            } catch (error) {
                document.getElementById('result').innerHTML = `<p style="color: red;">네트워크 오류: ${error.message}</p>`;
            }
        }

        async function testWeatherStats() {
            try {
                const response = await fetch(`${API_BASE}/api/weather/statistics/`);
                const data = await response.json();
                
                if (data.success) {
                    const stats = data.data;
                    let html = '<h3>날씨 데이터 통계</h3>';
                    html += `<div class="weather-card">
                        <strong>현재 날씨:</strong> ${stats.current_weather}건<br>
                        <strong>단기 예보:</strong> ${stats.short_forecast}건<br>
                        <strong>중기 예보:</strong> ${stats.mid_forecast}건<br>
                        <strong>구버전 데이터:</strong> ${stats.legacy_data}건<br>
                        <strong>총합:</strong> ${stats.total}건
                    </div>`;
                    document.getElementById('result').innerHTML = html;
                } else {
                    document.getElementById('result').innerHTML = `<p style="color: red;">오류: ${data.error}</p>`;
                }
            } catch (error) {
                document.getElementById('result').innerHTML = `<p style="color: red;">네트워크 오류: ${error.message}</p>`;
            }
        }

        async function testWeatherRecommendation() {
            try {
                // 중기 예보 데이터 가져오기
                const response = await fetch(`${API_BASE}/api/weather/mid-forecast/`);
                const data = await response.json();
                
                if (data.success) {
                    // 프론트엔드 로직으로 추천 계산
                    const recommendation = calculateWeatherRecommendation(data.data);
                    
                    let html = '<h3>날씨 기반 여행 추천</h3>';
                    html += `<div class="weather-card">
                        <div class="score-circle">${recommendation.score}</div>
                        <strong>${recommendation.message}</strong>
                    </div>`;
                    
                    html += '<h4>추천 날짜 TOP 3</h4>';
                    recommendation.bestDays.slice(0, 3).forEach((day, index) => {
                        html += `<div class="weather-card best-day">
                            <strong>#${index + 1} ${day.formattedDate}</strong><br>
                            온도: ${day.daily?.minTemp || '?'}°~${day.daily?.maxTemp || '?'}°<br>
                            강수확률: ${Math.round(((day.am?.rainProb || 0) + (day.pm?.rainProb || 0)) / 2)}%<br>
                            점수: ${day.score}점
                        </div>`;
                    });
                    
                    document.getElementById('result').innerHTML = html;
                } else {
                    document.getElementById('result').innerHTML = `<p style="color: red;">오류: ${data.error}</p>`;
                }
            } catch (error) {
                document.getElementById('result').innerHTML = `<p style="color: red;">네트워크 오류: ${error.message}</p>`;
            }
        }

        // 날씨 추천 로직 (React 컴포넌트와 동일)
        function formatMidForecastData(midForecastData) {
            if (!midForecastData || !Array.isArray(midForecastData)) return [];

            const groupedByDate = {};
            
            midForecastData.forEach(item => {
                const date = item.date;
                if (!groupedByDate[date]) {
                    groupedByDate[date] = {
                        date: date,
                        region: item.region,
                        am: null,
                        pm: null,
                        daily: null
                    };
                }
                
                if (item.period === 'Am') {
                    groupedByDate[date].am = {
                        weather: item.weather_condition !== 'nan' ? item.weather_condition : '정보없음',
                        rainProb: item.rain_probability || 0
                    };
                } else if (item.period === 'Pm') {
                    groupedByDate[date].pm = {
                        weather: item.weather_condition !== 'nan' ? item.weather_condition : '정보없음',
                        rainProb: item.rain_probability || 0
                    };
                } else if (item.period === '하루') {
                    groupedByDate[date].daily = {
                        minTemp: item.min_temperature,
                        maxTemp: item.max_temperature
                    };
                }
            });
            
            return Object.values(groupedByDate)
                .sort((a, b) => a.date.localeCompare(b.date))
                .map(item => ({
                    ...item,
                    formattedDate: formatDate(item.date),
                    hasValidData: item.daily && (item.daily.minTemp || item.daily.maxTemp)
                }));
        }

        function formatDate(dateString) {
            if (!dateString || dateString.length !== 8) return dateString;
            
            const year = dateString.substring(0, 4);
            const month = dateString.substring(4, 6);
            const day = dateString.substring(6, 8);
            
            const date = new Date(year, month - 1, day);
            const today = new Date();
            const tomorrow = new Date(today);
            tomorrow.setDate(today.getDate() + 1);
            
            if (date.toDateString() === today.toDateString()) {
                return '오늘';
            } else if (date.toDateString() === tomorrow.toDateString()) {
                return '내일';
            } else {
                return `${month}/${day}`;
            }
        }

        function calculateWeatherRecommendation(midForecastData) {
            const formattedData = formatMidForecastData(midForecastData);
            
            if (!formattedData || formattedData.length === 0) {
                return {
                    score: 0,
                    message: '날씨 정보가 없습니다',
                    bestDays: [],
                    worstDays: []
                };
            }

            const validDays = formattedData.filter(day => day.hasValidData);
            if (validDays.length === 0) {
                return {
                    score: 0,
                    message: '유효한 날씨 데이터가 없습니다',
                    bestDays: [],
                    worstDays: []
                };
            }

            // 각 날짜별 점수 계산
            const scoredDays = validDays.map(day => {
                let score = 50; // 기본 점수
                
                // 온도 점수 (15-25도가 최적)
                if (day.daily.maxTemp) {
                    const maxTemp = day.daily.maxTemp;
                    if (maxTemp >= 15 && maxTemp <= 25) {
                        score += 20;
                    } else if (maxTemp >= 10 && maxTemp <= 30) {
                        score += 10;
                    } else {
                        score -= 10;
                    }
                }
                
                // 강수 확률 점수
                const avgRainProb = ((day.am?.rainProb || 0) + (day.pm?.rainProb || 0)) / 2;
                if (avgRainProb <= 20) {
                    score += 20;
                } else if (avgRainProb <= 40) {
                    score += 10;
                } else if (avgRainProb <= 60) {
                    score -= 10;
                } else {
                    score -= 20;
                }
                
                return { ...day, score };
            });

            // 정렬
            const sortedDays = scoredDays.sort((a, b) => b.score - a.score);
            const avgScore = scoredDays.reduce((sum, day) => sum + day.score, 0) / scoredDays.length;

            return {
                score: Math.round(avgScore),
                message: getScoreMessage(avgScore),
                bestDays: sortedDays.slice(0, 3),
                worstDays: sortedDays.slice(-2).reverse(),
                allDays: sortedDays
            };
        }

        function getScoreMessage(score) {
            if (score >= 80) return '완벽한 여행 날씨입니다! 🌟';
            if (score >= 70) return '여행하기 좋은 날씨입니다 ☀️';
            if (score >= 60) return '괜찮은 날씨입니다 🌤️';
            if (score >= 50) return '보통 날씨입니다 ⛅';
            if (score >= 40) return '주의가 필요한 날씨입니다 🌧️';
            return '여행을 미루는 것을 고려해보세요 ⛈️';
        }
    </script>
</body>
</html>